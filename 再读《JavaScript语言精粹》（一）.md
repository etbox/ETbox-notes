2018.1.26
已经读完前4章了，是时候做一点笔记了。再读一遍，很多之前看不懂的地方已经能弄明白了，同时还残留一点至今也没弄明白的问题。希望现在把心得记录下来，下次看肯定又会有不一样的感受。

### chapter 1
这章最重要的知识点应该是用method方法去定义新方法。
```javascript
Function.prototype.method = function (name, func) {
  this.prototype[name] = func;
  return this;
};
```
一行一行来看这段代码：

第一行中，method是一个方法，它定义在Function的原型上。这导致的后果是它改写了原生的Function，并且所有的函数都可以调用method方法来定义一个新方法。

第二行其实可以和第三行一起看，最主要的是this的指向。以前一直不明白this到底要怎么判断指向，现在一眼就能看出指向的是调用method方法的函数。第二行就是说现在有一个构造函数调用了method方法，在这个构造函数的原型上绑定一个键为name，值为func的方法。要注意的是这里name没有用.提取，而是用[]提取，一方面是因为.name就相当于绑定了构造函数的name属性，另一方面是用[]里面可以放表达式或者诸如'class'、'data-role'这类保留字或者特殊字符。

第三行将this给返回了，本来这一步可以省略的，因为在第二行已经将方法添加到原型上了，返回this的主要目的应该是链式调用。因为不写return的话，函数会默认返回undefined，但是返回this就能做更多的事情。

### chapter 2
> 注释一定要精确地描述代码。没有用的注释比没有注释更糟糕

要避免使用```/* */```注释，因为注释内可能会有意料之外的正则表达式，如```/a*/```终止注释。

JavaScript的数字在内部被表示为64位浮点数，和Java的double数字类型一样，所以有时候会出现奇怪的bug，如```0.3 - 0.2 !== 0.1```

字符串是基本类型，所以一旦创建就是不可变的。

for...in语句会枚举一个对象的所有键名，所以包括原型链上的，注意用obj.hasOwnProperty(myvar)进行筛选。

throw和return一样会跳出当前函数调用。

JavaScript中的%不是正常的模运算，是“求余”运算，两个运算数中存在负数时会有差异。

**合法的标识符与表达式是不相同的！！！** 随着学习的深入，我越来越意识到两者的差异

### chapter 3
||运算符可以用来填充默认值，前面放预期的值，后面放防止意外发生的值。

> 对象通过引用来传递，它们永远不会被复制

只要出现连续赋值就要注意，先确定地址，后确定值。

原型关系是一种动态关系，向原型添加一个新属性，会让所有实例更新该属性。

for...in语句属性名是不确定的（其实会先出现数字数字属性），不能依赖创建时的顺序。

只创建唯一一个全局变量，把全局性的资源都纳入一个名称空间之下，这是减少冲突的好办法。

### chapter 4
> 所谓编程，就是将一组需求分解成一组函数与数据结构的技能

函数是对象，有一个特殊的prototype属性，它的值是一个拥有constructor属性且值为该函数的对象。

函数字面量即匿名函数。函数的参数在**被调用时**才初始化。

被当做方法被调用时，this在**被调用时**才绑定。

被当成普通函数调用时，this会被绑定到全局对象，用that保存this，以在内部函数中正确的获得该函数自身。

一般将构造函数的首字母大写。用new来调用构造函数的时候，this会指向实例。

ES6加入了尾调用优化，即不在调用栈上添加一个新的堆栈帧——而是更新它，所以只占用常量的站空间。

由于JavaScript的函数作用域及声明提升，所以在函数体顶部声明所有要用到的变量是最佳实践。

使用闭包要注意保存this和arguments，他们会随着函数的深入而更新。注意回收闭包所占用的内存，防止内存泄漏。

事件处理函数会绑定**变量本身**，而不是函数**在构造时**的变量的值。

模块可以减少每次函数调用时，某些变量初始化的时间，代价是一直占用内存。

模块模式的优势在于可以创建私有变量和函数，只有特权函数才能访问到，即使添加新的方法也无法访问私有属性。

让方法返回this，以链式调用。

柯里化和记忆不能完全理解，需要继续读《JavaScript函数式编程》。
