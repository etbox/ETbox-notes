这两天想研究素数，因为信息安全正好讲到初等数论的知识，而算法课讲到了动态规划，正好把两方面的知识结合起来，研究一下筛法找素数。以下是素数的定义：

> 如果正整数a大于1且只能被1和它自己整除，则称a是素数。

在学习程序设计语言基础的时候，我们做过找素数的题。由于是刚开始学编程，我们写的代码差不多是这个样子的：

```javascript
function isPrime(n) {  // 传入正整数n
  if (n <= 1) {  // 1不是素数，小于1的数也不是素数
    return false;
  } else {  // 只有大于1的数才可能是素数
    for (let i = 2; i < n; i++) {  // 根据定义，判断除了1和它自己的数能不能被它整除
      if (n % i === 0) {
        return false;
      }
    }
  }
  return true;
}
```

代码风格是还原不来的了，但是算法的思想大致是这个样子。根据定义，将符合要求的数全部过一遍，最后还没被淘汰的话就是素数。
后来或是经过老师的点拨，或是自己开悟，发现根本不需要把所有的数遍历一遍呀，只需要遍历到√n就行了。严谨一点讲是因为有下面这个定理：

> 如果a是一个合数，则a必有一个小于等于√a的真因子。

于是我们可以根据这个定理写一个复杂度更低的算法：

```javascript
function isPrime(n) {
  let root = Math.floor(Math.sqrt(n)),  // 从θ(n)的复杂度降到了θ(n^0.5)
    flag = true;  // 思想更加进步了，学会用标志了

  if (n <= 1) {
    flag = false;
  }

  for (let i = 2; i <= root; i++) {
    if (n % i === 0) {
      flag = false;
      break;
    }
  }

  return flag;
}
```

那么现在这个算法在判断一个特定的数是否为素数上，看起来已经找不到更好的了，直到我学习了筛法。

> 10以内的素数是2，3，5，7，用它们除以100以内大于10的数，删去所有能被它们整除的数，剩下的（含2，3，5，7在内）就是100以内的所有素数。

> 重复这个做法可以得到任意给定的正整数以内的所有素数，这个方法称作埃拉托斯特尼（Eratosthene)筛法。

> ——《离散数学》

筛法的核心思想是上面的定理的推论。

> 如果a是一个合数，则a必有一个小于等于√a的素因子

看起来只是把“真因子”换成了“素因子”，但其实素因子包含在真因子内，而真因子还有包含合数的情况。也就是说，我们在知道一个最小的素数的情况下，就可以把一个特定的数内所有的素数都找出来！我们先描述一下这个算法的具体步骤：
1. 我们需要一个装素数的数组，并且要记录它筛选了多大范围的数。
1. 判断素数的范围与给定范围的开平方。若素数的范围更大，则继续执行，否则递归调用该算法，将给定范围改成其开平方。
1. 我们还需要一个数组来标记给定范围内的数是否是素数。
1. 然后遍历给定范围内的每个数，令其对已知的素数取模。若取模的结果为0，则说明这个数是合数，并将其标记。
1. 遍历标记数组，对其中每个没被标记的数加入到素数数组内。
1. 更新素数的范围

###### 这个算法有一个要注意的点，就是要记录包含素数的范围。
我们来举个例子，当前已知最小的素数是2，我们要求10以内的所有素数。如果不记录素数的范围，也就是跳过第第二步，而直接使用筛法的话，我们将会得到3，5，7，9四个数。很明显，9不是素数，但是却被包含进来了。问题就出在素数的范围是2，但是√10向下取整是3，比2大，所以就出错了。

我们来看一下该算法的代码实现：

```javascript
function eratosthene(primes, n) {  // 筛法
  let root = Math.floor(Math.sqrt(n));  // 先要确定给定范围的开平方

  if (root > primes.range) {  //将其与素数的范围比较，若素数的范围不够大，则先扩展素数的范围
    eratosthene(primes, root);
  }

  let bool = new Array(n);  // 用来标记给定范围的素数合数的数组
  for (let i = 0; i < bool.length; i++) {  // 对其进行初始化，默认都是素数
    bool[i] = true;
    if (i < root || i < 2) {  // 两种特殊情况：1.因为素数的范围足够大，那么该范围内就不需要再进行判断，我们取其下界root；2.小于2的数都不是素数，这是预防给定的范围过小，如2、3、4而产生bug
      bool[i] = false;
    }
  }

  for (let i = root; i < bool.length; i++) {  // 筛法的核心，我们从root开始遍历
    if (i <= 2) {  // 同样预防给定的范围过小
      continue;
    }
    for (let j = 0; j < primes.length; j++) {  // 对每个数用已知的素数筛选
      if ((i + 1) % primes[j] === 0) {  // 对被筛选掉的数进行标记，并且结束循环，判断下一个数
        bool[i] = false;
        break;
      }
    }
  }

  for (let i = 0; i < bool.length; i++) {  // 更新素数数组
    if (bool[i] === true) {
      primes.push(i + 1);
    }
  }
  primes.range = n;  // 更新素数的范围
}
```

要想使用这个函数，我们除了要传入给定的范围n，还需要素数数组primes。

```javascript
let primes = [2];
primes.range = 2;
```

现在我们就可以愉快的调用这个函数了，例如：

```javascript
eratosthene(primes, 100);
console.log(primes);
console.log(primes.length);
```

我们可以看到输出如下：

```
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,range: 100]
25
```

现在我们来分析一下该算法的复杂度：
1. 计算平方根可以视为花费θ(1)的时间。
1. 递归运算可以忽略，因为计算的是原问题的子问题，肯定会比原问题的复杂度低，故忽略。
1. 创建标记数组花费θ(1)的时间，初始化标记数组花费θ(n)的时间
1. 筛法的核心部分分析起来就比较麻烦了，第一重循环肯定有一个θ(n)保底，最主要的是素数的个数，我们设其为x那么双重循环的复杂度应该为θ(n * x)。x不容易直接计算，但是我们知道素数分布定理：对于自然数n，不大于n的素数的个数约等于n / (ln n)。于是推出x就有着落了，奈何本人水平有限，只能找到别人的推导：[普通筛法时间界 O(nlnlnn) 的证明](http://blog.csdn.net/OIljt12138/article/details/53861367)。结论就是x为lnlnn，筛法核心部分的复杂度为θ(nlnlnn)。
1. 最后更新数组花费θ(n)的时间，更新素数范围花费θ(1)的时间。
1. 综上，筛法的复杂度为θ(nlnlnn)。

再来对比一下我们刚开始写的算法：

```javascript
function traditionalFunc(primes, n) {
  for (let i = 1; i <= n; i++) {
    if (isPrime(i)) {
      primes.push(i);
    }
  }
}

function isPrime(n) {
  let root = Math.floor(Math.sqrt(n)),
    flag = true;

  if (n <= 1) {
    flag = false;
  }

  for (let i = 2; i <= root; i++) {
    if (n % i === 0) {
      flag = false;
      break;
    }
  }

  return flag;
}

let primes = [];

traditionalFunc(primes, 1);
console.log(primes);
console.log(primes.length);
```

输出和筛法的输出一样，我们再来分析一下它的复杂度：
1. isPrime函数外面包了一层循环，内部是简单的数组操作，花费θ(1)，故复杂度又是θ(n * x)的结构。
1. 再看看isPrime本身，变量声明与赋值耗费θ(1)的时间，判断n的大小也耗费θ(1)的时间。
1. 循环判断耗费θ(√n)的时间，故最终传统算法的复杂度为θ(n√x)。

为了比较两个算法的速度，我还专门记录了跑程序的时间：

n|1|10|100|1000|10000|100000|1000000|10000000|100000000
-|
筛法（单位：秒）|0.5|0.53|0.53|0.54|0.54|0.54|0.69|2.7|49.9
传统法（单位：秒）|0.53|0.52|0.53|0.55|0.54|0.56|0.91|9.56|236

前几项的运行速度接近应该是由于程序的局部性原理所致。我们可以发现，从一百万开始，两种算法的速度开始拉开差距。到一亿的时候，传统法已经跑了将近4分钟。我都不敢跑十亿了，万一跑几个钟还没跑完，简直不敢想象。

最后总结一下。正所谓温故而知新，一个普通的求素数算法经过拓展，变化出的新算法令人眼前一亮。从算法的思路、代码的实现，再到复杂度的分析，每一步对我来说都是一个新的挑战。但是在不断的挑战中，我同时也在进步着。希望自己能在不断的进步中走出一条自己的路。
